#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# SPDX-License-Identifier: MIT
"""
Spotify playlist mixer — plně YAML-only

Author: Michal Vaněk <vanek@agmepro.cz>
Copyright (c) 2025 Michal Vaněk
License: MIT — see LICENSE.md

Popis:
- Všechna nastavení (OAuth, mix, kategorie) jsou v jednom souboru: sources.yaml
- Umí automaticky vybrat první volný port z 'oauth.redirect_ports' (musí být whitelisted).
- Nepřidává duplikáty v rámci jednoho běhu; při vyčerpání zdrojů skončí dřív.
"""
"""
Spotify playlist mixer with ratio pattern + fallback playlists.
- Respects OVERWRITE_PLAYLIST (true/false): replace vs. append.
- Auto-picks a free redirect port from REDIRECT_PORTS if provided.
- No duplicates within one run; stops early if sources are exhausted.

Works on macOS, Windows, Linux (Python 3.10+).
"""

import os
import re
import random
import sys
import socket
from typing import Dict, List, Tuple

import yaml
import spotipy
from spotipy.oauth2 import SpotifyOAuth

CONFIG_PATH = os.path.join(os.path.dirname(__file__), "sources.yaml")

# -------------------- Pomocné funkce --------------------
def fail(msg: str) -> None:
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(1)

def _is_port_free(port: int) -> bool:
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("127.0.0.1", port))
        s.close()
        return True
    except OSError:
        return False

def extract_playlist_id(s: str) -> str:
    """Přijme playlist URL/URI/ID a vrátí čisté ID."""
    if not s:
        return ""
    s = s.strip()
    m = re.match(r"spotify:playlist:([A-Za-z0-9]+)", s)
    if m:
        return m.group(1)
    m = re.match(r"https?://open\.spotify\.com/playlist/([A-Za-z0-9]+)", s)
    if m:
        return m.group(1)
    if re.match(r"^[A-Za-z0-9]+$", s):
        return s
    return ""

def parse_pattern(text: str) -> List[Tuple[str, int]]:
    out: List[Tuple[str, int]] = []
    parts = [p for p in text.split(",") if p.strip()]
    if not parts:
        fail("V YAMLu chybí mix.pattern (např. 'bachata:3,kizomba:3').")
    for part in parts:
        if ":" not in part:
            fail(f"PATTERN položka '{part}' je neplatná. Použij tvar nazev:počet.")
        key, count = part.split(":", 1)
        key = key.strip().lower()
        try:
            c = int(count.strip())
        except ValueError:
            fail(f"PATTERN počet '{count}' není číslo.")
        if c <= 0:
            fail(f"PATTERN počet pro '{key}' musí být kladný.")
        out.append((key, c))
    return out

def fetch_playlist_tracks(sp: spotipy.Spotify, playlist_id: str) -> List[str]:
    """Vrátí seznam track ID pro daný playlist (bez lokálních/nepřístupných)."""
    results = sp.playlist_items(playlist_id, additional_types=["track"], limit=100)
    tracks: List[str] = []
    while True:
        for it in results.get("items", []):
            track = it.get("track")
            if not track:
                continue
            tid = track.get("id")
            if tid:
                tracks.append(tid)
        next_url = results.get("next")
        if not next_url:
            break
        results = sp.next(results)
    # deduplikace se zachováním pořadí
    seen = set()
    unique: List[str] = []
    for t in tracks:
        if t not in seen:
            seen.add(t)
            unique.append(t)
    return unique

def fetch_many_playlists(sp: spotipy.Spotify, refs: List[str]) -> List[str]:
    """Sloučí více playlistů, dedupuje v pořadí výskytu."""
    all_tracks: List[str] = []
    seen = set()
    for ref in refs:
        pid = extract_playlist_id(ref)
        if not pid:
            continue
        tracks = fetch_playlist_tracks(sp, pid)
        for t in tracks:
            if t not in seen:
                seen.add(t)
                all_tracks.append(t)
    return all_tracks

def find_or_create_playlist(sp: spotipy.Spotify, user_id: str, name: str, public: bool) -> str:
    # najdi existující podle názvu
    limit, offset = 50, 0
    while True:
        pl = sp.current_user_playlists(limit=limit, offset=offset)
        for item in pl.get("items", []):
            if item["name"] == name:
                return item["id"]
        if len(pl.get("items", [])) < limit:
            break
        offset += limit
    # nebo vytvoř nový
    created = sp.user_playlist_create(user_id, name, public=public, description="Auto-generated by spotify_mixer.py")
    return created["id"]

def chunked(seq: List[str], n: int):
    for i in range(0, len(seq), n):
        yield seq[i:i+n]

def build_mix_with_fallbacks(sources: Dict[str, Dict[str, List[str]]],
                             pattern: List[Tuple[str,int]],
                             target: int) -> List[str]:
    # promíchání pro pestrost
    for key in sources:
        random.shuffle(sources[key]["main"])
        random.shuffle(sources[key]["extra"])
    idx_main  = {k: 0 for k in sources}
    idx_extra = {k: 0 for k in sources}
    len_main  = {k: len(v["main"]) for k, v in sources.items()}
    len_extra = {k: len(v["extra"]) for k, v in sources.items()}
    used: set = set()
    out: List[str] = []
    safety = 0
    max_attempts = target * 10

    def next_from(cat: str):
        # zkus main
        tries = 0
        while tries < len_main[cat]:
            if len_main[cat] == 0:
                break
            pos = idx_main[cat] % max(1, len_main[cat])
            idx_main[cat] += 1
            tries += 1
            cand = sources[cat]["main"][pos]
            if cand not in used:
                return cand
        # pak extra
        tries = 0
        while tries < len_extra[cat]:
            if len_extra[cat] == 0:
                break
            pos = idx_extra[cat] % max(1, len_extra[cat])
            idx_extra[cat] += 1
            tries += 1
            cand = sources[cat]["extra"][pos]
            if cand not in used:
                return cand
        return None

    while len(out) < target and safety < max_attempts:
        for key, count in pattern:
            for _ in range(count):
                cand = next_from(key)
                if cand is not None:
                    out.append(cand)
                    used.add(cand)
                    if len(out) >= target:
                        break
            if len(out) >= target:
                break
        safety += 1
        # všechno vyčerpané?
        any_left = False
        for k in sources:
            if any(t not in used for t in sources[k]["main"]) or any(t not in used for t in sources[k]["extra"]):
                any_left = True
                break
        if not any_left:
            if len(out) < target:
                print("Poznámka: Zdroje došly dřív než target_length; končím dřív.")
            break
    return out

# -------------------- YAML načtení --------------------
def load_yaml_config(path: str):
    if not os.path.exists(path):
        fail(f"Soubor '{path}' neexistuje. Vytvoř si ho podle 'sources.example.yaml'.")
    with open(path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f) or {}
    if not isinstance(data, dict):
        fail("YAML musí být objekt (mapping).")

    # OAuth
    oauth = data.get("oauth") or {}
    if not isinstance(oauth, dict):
        fail("V YAMLu musí být sekce 'oauth' jako objekt.")
    client_id = (oauth.get("client_id") or "").strip()
    client_secret = (oauth.get("client_secret") or "").strip()
    redirect_uri = (oauth.get("redirect_uri") or "").strip()
    redirect_ports = oauth.get("redirect_ports") or []
    if not client_id or not client_secret:
        fail("V 'oauth' chybí client_id nebo client_secret.")
    if not redirect_uri:
        redirect_uri = "http://127.0.0.1:8080/callback"
    # Auto-pick first free port from redirect_ports
    chosen_redirect = None
    if isinstance(redirect_ports, list) and redirect_ports:
        for p in redirect_ports:
            try:
                port = int(p)
            except Exception:
                continue
            if _is_port_free(port):
                chosen_redirect = f"http://127.0.0.1:{port}/callback"
                print(f"Používám Redirect URI (auto): {chosen_redirect}")
                break
    if not chosen_redirect:
        print(f"Používám Redirect URI: {redirect_uri}")
        chosen_redirect = redirect_uri

    # Mix
    mix = data.get("mix") or {}
    if not isinstance(mix, dict):
        fail("V YAMLu musí být sekce 'mix' jako objekt.")
    playlist_name = mix.get("playlist_name") or "Dance Mix"
    public = bool(mix.get("public", False))
    pattern_text = mix.get("pattern") or ""
    target_length = int(mix.get("target_length", 200))
    overwrite = bool(mix.get("overwrite", True))
    pattern = parse_pattern(pattern_text)

    # Categories
    cats = data.get("categories", {}) or {}
    if not isinstance(cats, dict):
        fail("V YAMLu 'categories' musí být objekt (mapping).")
    categories = {}
    for name, cfg in cats.items():
        if not isinstance(cfg, dict):
            fail(f"Kategorie '{name}' musí být objekt.")
        main = cfg.get("main", [])
        fallbacks = cfg.get("fallbacks", [])
        # normalizace na seznamy stringů
        def norm_list(x):
            if isinstance(x, str):
                return [x] if x.strip() else []
            if isinstance(x, list):
                return [i for i in x if isinstance(i, str) and i.strip()]
            return []
        categories[name.strip().lower()] = {
            "main": norm_list(main),
            "fallbacks": norm_list(fallbacks),
        }

    # validace pattern vs. kategorie
    known = set(categories.keys())
    unknown = [k for k, _ in pattern if k not in known]
    if unknown:
        fail(f"PATTERN obsahuje neznámé kategorie: {unknown}. Známé: {sorted(known)}")

    return {
        "client_id": client_id,
        "client_secret": client_secret,
        "redirect_uri": chosen_redirect,
        "playlist_name": playlist_name,
        "public": public,
        "pattern": pattern,
        "target_length": target_length,
        "overwrite": overwrite,
        "categories": categories,
    }

# -------------------- Hlavní běh --------------------
def main():
    cfg = load_yaml_config(CONFIG_PATH)
    print(f"Používám PATTERN: {cfg['pattern']}")
    print(f"Target length: {cfg['target_length']}")

    # Spotify klient
    scope = "playlist-modify-public playlist-modify-private playlist-read-private"
    auth_manager = SpotifyOAuth(
        client_id=cfg["client_id"],
        client_secret=cfg["client_secret"],
        redirect_uri=cfg["redirect_uri"],
        scope=scope,
        open_browser=True,
        show_dialog=False,
        cache_path=".cache-spotify-mixer",
    )
    sp = spotipy.Spotify(auth_manager=auth_manager)
    me = sp.me()
    print(f"Přihlášen jako: {me['id']}")

    print("Načítám playlisty...")
    sources: Dict[str, Dict[str, List[str]]] = {}
    for name, c in cfg["categories"].items():
        # main
        main_refs = c["main"]
        main_tracks_all: List[str] = []
        for ref in main_refs:
            pid = extract_playlist_id(ref)
            if pid:
                main_tracks_all += fetch_playlist_tracks(sp, pid)
        # dedupe
        seen = set()
        main_tracks: List[str] = []
        for t in main_tracks_all:
            if t not in seen:
                seen.add(t)
                main_tracks.append(t)
        # fallbacks
        extra_tracks = fetch_many_playlists(sp, c["fallbacks"])
        sources[name] = {"main": main_tracks, "extra": extra_tracks}
        print(f"  {name}: main={len(main_tracks)}  extra={len(extra_tracks)}")

    if all(len(sources[k]['main']) + len(sources[k]['extra']) == 0 for k in sources):
        fail("Všechny zdrojové playlisty jsou prázdné.")

    print("Stavím výsledný mix...")
    mixed = build_mix_with_fallbacks(sources, cfg["pattern"], cfg["target_length"])
    print(f"Postaveno skladeb: {len(mixed)}")

    print("Vytvářím/aktualizuji cílový playlist...")
    dst_id = find_or_create_playlist(sp, me["id"], cfg["playlist_name"], cfg["public"])
    if cfg["overwrite"]:
        # nahraď celé pořadí
        first = mixed[:100]
        sp.playlist_replace_items(dst_id, first)
        for i in range(100, len(mixed), 100):
            sp.playlist_add_items(dst_id, mixed[i:i+100])
    else:
        # jen přidej navrch
        for i in range(0, len(mixed), 100):
            sp.playlist_add_items(dst_id, mixed[i:i+100])

    print("Hotovo.")
    print(f"Playlist '{cfg['playlist_name']}' je aktualizován.")

if __name__ == "__main__":
    main()
